发现`p`和`q`都是形如`x^4+a`其中`x`是128位的数，而`a`是70位的数。假设`p=x^4+a`，`q=y^4+b`很容易得到`n=p*q=(x*y)^4+a*y^4+b*x^4+a*b`

由于`a和b过小`，如果对`n`直接开四次方根，可以得到`n^(1/4) == x*y`

于是可以根据`n^(1/4) == x*y`以及`p=x^4+a`，`q=y^4+b`求

解`x和y`其中`a,b`均已知，使用sage求解方程

```python
n_root = 213145517693473276472741453960288533380429305903664848348709095184411519973440
r_p,r_q = 2328957326808590967503,1461823189315446122067
n = 2063976825250272595388593010902135884890103500050668819831297298752625852801511751408065791793019547189652146900555099774958963484251389843293161492169372162099883268521841628059721206917183539122495978771222844176897602295938111287844515247614001317395469781055421827261855002882782439392377329027883959379213
# (x*y) == iroot(n,4)[0]
# (x^4+a)*(y^4+b) == n
var('x,y')
eq1 = x*y == n_root
eq2 = (x^4+r_p)*(y^4+r_q) == n
solve([eq1,eq2],[x,y])
```

得到

[x == 411149993498066384380477696729089782688, y == 518413039192899046033157413963674073130]

于是得知p,q

```
p = x**4+r_p
q = y**4+r_q
```

继而可求 phi、d，RSA得解

```python
from gmpy2 import *
r_p,r_q = 2328957326808590967503,1461823189315446122067
n = 2063976825250272595388593010902135884890103500050668819831297298752625852801511751408065791793019547189652146900555099774958963484251389843293161492169372162099883268521841628059721206917183539122495978771222844176897602295938111287844515247614001317395469781055421827261855002882782439392377329027883959379213
c = 1231814651452490754232312798025686864585814261950598686677331772415177021213364996279168286991145893165513812663113234909346648556730940320954497929812998184053325485834402250982161120096731206233876867776810367342225449526633927351249754576593795583093772705499865653601091174659104761546312651756619187702564
x = 411149993498066384380477696729089782688
y = 518413039192899046033157413963674073130
p = x**4+r_p
q = y**4+r_q

phi = (p-1)*(q-1)
e = 0x10001
# dd*(e//2) = 1 mod phi ==> dd*0x10001 = 1 mod phi
dd = invert(e,phi)
# c == m^e
# m^(e*dd) mod n ==> n^(2*0x10001*dd) mod n ==> m^2 mod n
M = pow(c,dd,n)
flag = M
print(bytes.fromhex(hex(flag).strip("0xL")))
```

flag

```
jnctf{b3st_crypt0}
```

